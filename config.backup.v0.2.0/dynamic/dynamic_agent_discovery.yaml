# Dynamic Agent Discovery System
# Real-time agent detection and initialization

metadata:
  name: "dynamic-agent-discovery"
  version: "0.0.1"
  description: "Dynamic agent discovery and real-time initialization system"
  author: "Master Agent System v0.0.1"

# Core Discovery Algorithm
discovery_algorithm:
  name: "Dynamic Agent Loader"
  version: "0.0.1"

  # Discovery Process
  process:
    step_1_filesystem_scan:
      description: "Scan filesystem for agent files"
      scan_paths: [
        "agents/",              # Project agents
        "subagents/",           # Project subagents
        ".claude/agents/",      # User system agents (if exists)
        "~/.claude/agents/"     # Global system agents (if exists)
      ]
      file_patterns: ["*.md"]
      extraction_method: "yaml_frontmatter"
      fallback_on_empty: true    # Continue even if no agents found

    step_2_validation:
      description: "Validate discovered agents"
      format_validation: "simple-name"  # Accept simple names from YAML frontmatter
      capability_check: true
      availability_check: true
      strict_validation: false         # More flexible validation

    step_3_caching:
      description: "Cache discovered agents"
      cache_duration: "session_lifetime"
      update_trigger: "registry_change"

    step_4_name_registration:
      description: "Dynamic name generation and registration"
      name_format: "category:agent-name"
      auto_categorization: true
      dynamic_name_generation: true

      # Category Detection Rules
      categorization_rules:
        capabilities_based:
          "orchestration": ["task-orchestration", "automatic-delegation", "agent-selection", "coordination", "manage", "parallel"]
          "development": ["frontend", "backend", "full-stack", "coding", "programming", "implementation"]
          "architecture": ["system-design", "architecture", "scalability", "patterns", "structure"]
          "security": ["security", "authentication", "authorization", "vulnerability", "penetration"]
          "testing": ["testing", "qa", "quality", "validation", "automation"]
          "research": ["research", "analysis", "investigation", "discovery", "exploration"]
          "performance": ["performance", "optimization", "speed", "efficiency", "monitoring"]
          "infrastructure": ["infrastructure", "devops", "deployment", "ci/cd", "operations"]

        triggers_based:
          "orchestration": ["orchestrate", "delegate", "coordinate", "manage", "parallel"]
          "development": ["implement", "code", "develop", "build", "create"]
          "architecture": ["design", "architecture", "plan", "structure"]
          "security": ["secure", "protect", "vulnerability", "attack"]
          "testing": ["test", "validate", "verify", "quality"]
          "research": ["research", "analyze", "investigate", "explore"]
          "performance": ["optimize", "performance", "speed", "efficiency"]
          "infrastructure": ["deploy", "infrastructure", "operations", "devops"]

        tools_based:
          "orchestration": ["sequential-thinking", "serena"]
          "development": ["magic", "context7", "morphllm"]
          "testing": ["playwright", "chrome-devtools"]
          "research": ["tavily", "web-search-prime", "context7"]
          "infrastructure": ["fast-filesystem"]

      # Name Resolution System
      name_resolution:
        # @agent-{name} resolution to dynamic names
        agent_prefix_resolution:
          enabled: true
          prefix: "@agent-"
          resolution_logic: "extract_name → detect_category → generate_dynamic_name"

        # Dynamic name generation
        dynamic_name_format: "{category}:{agent_name}"

        # Caching system for resolved names
        name_cache:
          enabled: true
          cache_duration: "session_lifetime"
          cache_key_format: "resolved_name_{original_name}"

        # Fallback mechanisms
        fallback_resolution:
          - strategy: "direct_match"
            description: "Use exact name if found in registry"
          - strategy: "category_inference"
            description: "Infer category from capabilities/triggers"
          - strategy: "default_category"
            description: "Use 'general' category if no inference possible"
            default_category: "general"

# Agent Detection Function
agent_detection_function: |
  # Dynamic Agent Discovery Function
  def discover_agents():
      """
      Dynamically discovers and validates available agents in the system
      Returns list of valid agent objects with metadata
      """

      discovered_agents = []

      # 1. Registry-based discovery (project agents)
      registry_agents = load_agent_registry()

      # 2. Filesystem-based discovery (project + system agents)
      filesystem_agents = scan_agent_files([
          "agents/",              # Project-specific agents
          "subagents/",           # Project subagents
          ".claude/agents/",      # User system agents
          "~/.claude/agents/"     # Global system agents
      ])

      # 3. Merge and deduplicate
      all_agents = merge_agent_sources(registry_agents, filesystem_agents)

      # 4. Validation for different agent types
      valid_agents = validate_agent_list(all_agents)

      # 5. Cache for performance
      cache_agent_list(valid_agents)

      return valid_agents

  def validate_agent_list(agents):
      """
      Validates both registry agents and system agents
      """
      valid_agents = []

      for agent in agents:
          if is_registry_agent(agent):
              # Registry agent validation (category:agent-name format)
              if validate_registry_agent(agent):
                  valid_agents.append(agent)
          elif is_system_agent(agent):
              # System agent validation (name format from YAML frontmatter)
              if validate_system_agent(agent):
                  valid_agents.append(agent)

      return valid_agents

  def get_available_agents():
      """
      Returns list of currently available agents
      """
      return get_cached_agents() or discover_agents()

  def validate_agent_name(agent_name):
      """
      Validates agent name against discovered agents
      """
      available_agents = get_available_agents()
      return find_agent_by_name(agent_name, available_agents)

  def generate_dynamic_agent_name(agent_data):
      """
      Generate dynamic name in format {category}:{agent_name}
      """
      agent_name = agent_data.get('name', 'unknown')

      # Check if already in dynamic format
      if ':' in agent_name:
          return agent_name

      # Detect category
      category = detect_agent_category(agent_data)

      # Generate dynamic name
      dynamic_name = f"{category}:{agent_name}"
      return dynamic_name

  def detect_agent_category(agent_data):
      """
      Detect agent category based on capabilities, triggers, and tools
      """
      capabilities = agent_data.get('capabilities', [])
      triggers = agent_data.get('triggers', [])
      tools = agent_data.get('tools', [])

      # Check capabilities-based categories
      if any(orch_term in ' '.join(capabilities).lower() for orch_term in
             ['task-orchestration', 'automatic-delegation', 'agent-selection', 'coordination']):
          return 'orchestration'

      if any(dev_term in ' '.join(capabilities).lower() for dev_term in
             ['frontend', 'backend', 'development', 'coding', 'programming']):
          return 'development'

      if any(arch_term in ' '.join(capabilities).lower() for arch_term in
             ['architecture', 'system-design', 'scalability', 'patterns']):
          return 'architecture'

      if any(sec_term in ' '.join(capabilities).lower() for sec_term in
             ['security', 'authentication', 'authorization', 'vulnerability']):
          return 'security'

      if any(test_term in ' '.join(capabilities).lower() for test_term in
             ['testing', 'qa', 'quality', 'validation', 'automation']):
          return 'testing'

      if any(research_term in ' '.join(capabilities).lower() for research_term in
             ['research', 'analysis', 'investigation', 'discovery']):
          return 'research'

      if any(perf_term in ' '.join(capabilities).lower() for perf_term in
             ['performance', 'optimization', 'speed', 'efficiency', 'monitoring']):
          return 'performance'

      if any(infra_term in ' '.join(capabilities).lower() for infra_term in
             ['infrastructure', 'devops', 'deployment', 'operations']):
          return 'infrastructure'

      # Check triggers-based categories
      if any(trig in ' '.join(triggers).lower() for trig in
             ['orchestrate', 'delegate', 'coordinate', 'manage', 'parallel']):
          return 'orchestration'

      # Check tools-based categories
      if any(tool in ' '.join(tools).lower() for tool in
             ['sequential-thinking', 'serena']):
          return 'orchestration'

      if any(tool in ' '.join(tools).lower() for tool in
             ['magic', 'context7', 'morphllm']):
          return 'development'

      if any(tool in ' '.join(tools).lower() for tool in
             ['playwright', 'chrome-devtools']):
          return 'testing'

      if any(tool in ' '.join(tools).lower() for tool in
             ['tavily', 'web-search-prime']):
          return 'research'

      # Default category
      return 'general'

  def resolve_agent_name_with_prefix(agent_request):
      """
      Resolve @agent-{name} to dynamic name format
      """
      # Check if it's @agent- prefix
      if agent_request.startswith('@agent-'):
          # Extract agent name
          agent_name = agent_request[7:]  # Remove '@agent-' prefix

          # Try to find in cache first
          cached_result = get_cached_name_resolution(agent_name)
          if cached_result:
              return cached_result

          # Find agent data
          available_agents = get_available_agents()
          agent_data = find_agent_data_by_name(agent_name, available_agents)

          if agent_data:
              # Generate dynamic name
              dynamic_name = generate_dynamic_agent_name(agent_data)
              cache_name_resolution(agent_name, dynamic_name)
              return dynamic_name
          else:
              # Fallback: generate with default category
              return f"general:{agent_name}"

      # Return as-is if not @agent- prefix
      return agent_request

  def get_cached_name_resolution(agent_name):
      """
      Get cached name resolution if available
      """
      cache_key = f"resolved_name_{agent_name}"
      # Implementation would check cache system
      return None  # Placeholder

  def cache_name_resolution(agent_name, dynamic_name):
      """
      Cache name resolution for future use
      """
      cache_key = f"resolved_name_{agent_name}"
      # Implementation would store in cache system
      pass  # Placeholder

  def find_agent_data_by_name(agent_name, available_agents):
      """
      Find agent data by name (simple or dynamic format)
      """
      for agent in available_agents:
          if agent.get('name') == agent_name:
              return agent
          # Also check if agent_name is part of dynamic name
          if ':' in agent.get('name', ''):
              category, name = agent.get('name', '').split(':', 1)
              if name == agent_name:
                  return agent
      return None

  # Integration with Domain System
  def integrate_with_domain_system(agent_data):
      """
      Integrate agent categorization with domain system feedback
      """
      if not DOMAIN_SYSTEM_INTEGRATION_ENABLED:
          return agent_data

      try:
          # Import domain system results
          domain_feedback = load_domain_system_feedback()

          if domain_feedback:
              # Apply domain-based enhancements
              enhanced_agent = enhance_agent_with_domain_data(agent_data, domain_feedback)

              # Update category confidence based on domain insights
              enhanced_agent = apply_domain_confidence_boosts(enhanced_agent, domain_feedback)

              # Check for category refinements
              enhanced_agent = refine_category_based_on_domains(enhanced_agent, domain_feedback)

              return enhanced_agent

      except Exception as e:
          log_integration_error("domain_system_integration", str(e))
          # Fallback to original agent data
          return agent_data

      return agent_data

  def load_domain_system_feedback():
      """
      Load feedback data from domain system
      """
      try:
          # Check for domain system feedback file
          feedback_file = "config/dynamic/domain_agent_feedback.yaml"
          if os.path.exists(feedback_file):
              with open(feedback_file, 'r') as f:
                  return yaml.safe_load(f)
      except Exception:
          pass
      return None

  def enhance_agent_with_domain_data(agent_data, domain_feedback):
      """
      Enhance agent data with domain system insights
      """
      enhanced = agent_data.copy()

      # Add domain insights
      agent_category = enhanced.get('detected_category', 'general')
      domain_insights = domain_feedback.get('agent_recommendations', {}).get('category_adjustments', {})

      if agent_category in domain_insights:
          domain_data = domain_insights[agent_category]

          # Apply confidence boosts
          if 'confidence_updates' in domain_data:
              enhanced['domain_confidence_boost'] = domain_data['confidence_updates']

          # Add domain-inferred capabilities
          if 'capability_refinements' in domain_data:
              enhanced.setdefault('domain_inferred_capabilities', []).extend(
                  domain_data['capability_refinements']
              )

          # Add cross-domain influences
          if 'cross_domain_influences' in domain_data:
              enhanced['cross_domain_categories'] = domain_data['cross_domain_influences']

      return enhanced

  def apply_domain_confidence_boosts(agent_data, domain_feedback):
      """
      Apply confidence boosts based on domain system analysis
      """
      enhanced = agent_data.copy()
      agent_category = enhanced.get('detected_category', 'general')

      # Get domain confidence scores
      domain_confidence = domain_feedback.get('domain_insights', {}).get('domain_confidence_scores', {})

      if agent_category in domain_confidence:
        confidence_score = domain_confidence[agent_category]

        # Apply boost if domain confidence is high
        if confidence_score > 0.8:
          boost_amount = 0.15  # From domain system config
          enhanced['category_confidence'] = min(1.0,
              enhanced.get('category_confidence', 0.7) + boost_amount)
          enhanced['confidence_boost_source'] = 'domain_system_high_confidence'

      return enhanced

  def refine_category_based_on_domains(agent_data, domain_feedback):
      """
      Refine agent category based on domain system evolution insights
      """
      enhanced = agent_data.copy()
      original_category = enhanced.get('detected_category', 'general')

      # Check for new category proposals
      new_categories = domain_feedback.get('agent_recommendations', {}).get('new_category_proposals', {})

      if original_category in new_categories:
        proposal = new_categories[original_category]

        # Apply refinement if confidence is high enough
        if proposal.get('confidence', 0) > 0.75:
          enhanced['original_category'] = original_category
          enhanced['detected_category'] = proposal['suggested_category']
          enhanced['category_refinement_source'] = 'domain_system_evolution'
          enhanced['refinement_confidence'] = proposal['confidence']

      return enhanced

  def generate_domain_feedback_for_agents(discovered_agents):
      """
      Generate feedback data for domain system based on discovered agents
      """
      feedback_data = {
        'timestamp': datetime.now().isoformat(),
        'agent_discovery_results': {
          'total_agents': len(discovered_agents),
          'categories': {},
          'confidence_distribution': {},
          'domain_correlations': {}
        }
      }

      # Analyze category distribution
      categories = {}
      for agent in discovered_agents:
        category = agent.get('detected_category', 'general')
        confidence = agent.get('category_confidence', 0.7)

        if category not in categories:
          categories[category] = []
        categories[category].append({
          'name': agent.get('name'),
          'confidence': confidence,
          'capabilities': agent.get('capabilities', [])
        })

      feedback_data['agent_discovery_results']['categories'] = categories

      # Generate domain correlation suggestions
      domain_correlations = generate_domain_correlation_suggestions(categories)
      feedback_data['agent_discovery_results']['domain_correlations'] = domain_correlations

      # Save feedback for domain system
      save_agent_discovery_feedback(feedback_data)

      return feedback_data

  def generate_domain_correlation_suggestions(categories):
      """
      Generate suggestions for domain correlations based on agent categories
      """
      correlations = {}

      for category, agents in categories.items():
        # Calculate average confidence
        avg_confidence = sum(a['confidence'] for a in agents) / len(agents)

        # Extract common capabilities
        all_capabilities = []
        for agent in agents:
          all_capabilities.extend(agent['capabilities'])

        # Find most common capabilities
        from collections import Counter
        capability_counts = Counter(all_capabilities)
        top_capabilities = capability_counts.most_common(5)

        correlations[category] = {
          'agent_count': len(agents),
          'average_confidence': avg_confidence,
          'top_capabilities': top_capabilities,
          'suggested_domains': get_domain_suggestions_for_category(category, top_capabilities)
        }

      return correlations

  def get_domain_suggestions_for_category(category, top_capabilities):
      """
      Get domain suggestions based on agent category and capabilities
      """
      # Map agent categories to suggested domains
      domain_mapping = {
        'orchestration': ['coordination_management', 'task_orchestration'],
        'development': ['frontend_development', 'backend_development'],
        'architecture': ['system_architecture', 'technical_design'],
        'security': ['security_analysis', 'vulnerability_assessment'],
        'testing': ['quality_assurance', 'testing_automation'],
        'research': ['research_analysis', 'knowledge_synthesis'],
        'performance': ['performance_optimization', 'efficiency_analysis'],
        'infrastructure': ['infrastructure_management', 'operations_automation'],
        'general': ['general_purpose', 'versatile_tasks']
      }

      return domain_mapping.get(category, ['general_purpose'])

  def save_agent_discovery_feedback(feedback_data):
      """
      Save agent discovery feedback for domain system consumption
      """
      try:
        feedback_file = "config/dynamic/agent_discovery_feedback.yaml"
        with open(feedback_file, 'w') as f:
          yaml.safe_dump(feedback_data, f, default_flow_style=False)
      except Exception as e:
        log_error(f"Failed to save agent discovery feedback: {e}")

  # Competency Matrix System Implementation
def create_competency_vectors(available_agents):
    """
    Creation of agent competency vectors for precise skill matching
    Reference: agents/master.md.backup (lines 626-642)
    """
    if not available_agents:
        return []

    # Extract all unique competencies across all agents
    all_competencies = set()
    for agent in available_agents:
        capabilities = agent.get('capabilities', [])
        all_competencies.update(capabilities)
        # Add capabilities from inferred categories
        detected_category = agent.get('detected_category', 'general')
        all_competencies.update(get_category_default_capabilities(detected_category))

    # Create competency list (sorted for consistency)
    competency_list = sorted(list(all_competencies))

    # Create competency vectors for each agent
    competency_vectors = []
    for agent in available_agents:
        vector = [1 if comp in agent.get('capabilities', []) else 0 for comp in competency_list]

        # Add category expertise indicators
        agent_category = agent.get('detected_category', 'general')
        if agent_category in ['orchestration', 'development', 'architecture', 'security']:
            vector[competency_list.index('task-orchestration')] = 1.0
        if agent_category in ['research', 'analysis', 'testing', 'performance']:
            vector[competency_list.index('research-analysis')] = 1.0

        competency_vectors.append({
            'agent_name': agent.get('name'),
            'agent_category': agent_category,
            'vector': vector,
            'raw_capabilities': agent.get('capabilities', []),
            'confidence': agent.get('category_confidence', 0.7)
        })

    return {
        'competency_list': competency_list,
        'agent_vectors': competency_vectors,
        'total_competencies': len(competency_list),
        'vector_dimensions': len(competency_list)
    }

def get_category_default_capabilities(category):
    """Get default capabilities for each agent category"""
    default_capabilities = {
        'orchestration': ['task-orchestration', 'automatic-delegation', 'agent-selection', 'coordination', 'manage', 'parallel'],
        'development': ['frontend', 'backend', 'coding', 'programming', 'implementation', 'design'],
        'architecture': ['architecture', 'system-design', 'scalability', 'patterns', 'structure'],
        'security': ['security', 'authentication', 'authorization', 'vulnerability', 'protection'],
        'testing': ['testing', 'qa', 'quality', 'validation', 'automation'],
        'research': ['research', 'analysis', 'investigation', 'discovery', 'exploration'],
        'performance': ['performance', 'optimization', 'speed', 'efficiency', 'monitoring'],
        'infrastructure': ['infrastructure', 'devops', 'deployment', 'ci/cd', 'operations']
    }
    return default_capabilities.get(category, [])

def build_dynamic_compatibility_matrix(categories, agent_vectors):
    """
    Generation of dynamic compatibility matrix
    Reference: agents/master.md.backup (lines 421-422)
    """
    compatibility_matrix = {}

    for category in categories:
        category_agents = [av for av in agent_vectors if av['agent_category'] == category]

        # Calculate compatibility scores for agents in this category
        agent_scores = {}
        for agent in category_agents:
            score = calculate_compatibility_score(agent, category)
            agent_scores[agent['agent_name']] = score

        compatibility_matrix[category] = {
            'sorted_agents': sorted(agent_scores.items(), key=lambda x: x[1], reverse=True),
            'all_scores': agent_scores,
            'top_agents': [agent for agent, score in agent_scores.items() if score > 0.3]
        }

    return compatibility_matrix

def calculate_compatibility_score(agent_vector, task_category):
    """
    Calculate compatibility score between agent capabilities and task category requirements
    Enhanced version with domain specialization and performance factors
    """
    agent_capabilities = agent_vector.get('raw_capabilities', [])
    agent_name = agent_vector.get('agent_name')

    # Base compatibility score
    score = 0.0

    # Check direct capability matches
    if task_category == 'orchestration':
        orchestration_comps = ['task-orchestration', 'automatic-delegation', 'agent-selection', 'coordination']
        for comp in orchestration_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(orchestration_comps))
    elif task_category == 'development':
        dev_comps = ['frontend', 'backend', 'coding', 'programming', 'implementation']
        for comp in dev_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(dev_comps))
    elif task_category == 'architecture':
        arch_comps = ['architecture', 'system-design', 'scalability', 'patterns', 'structure']
        for comp in arch_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(arch_comps))
    elif task_category == 'security':
        sec_comps = ['security', 'authentication', 'authorization', 'vulnerability', 'protection']
        for comp in sec_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(sec_comps))
    elif task_category == 'testing':
        test_comps = ['testing', 'qa', 'quality', 'validation', 'automation']
        for comp in test_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(test_comps))
    elif task_category == 'research':
        research_comps = ['research', 'analysis', 'investigation', 'discovery', 'exploration']
        for comp in research_comps:
            if comp in agent_capabilities:
                score += 1.0
        score /= max(1, len(research_comps))

    # Apply agent confidence boost
    agent_confidence = agent_vector.get('confidence', 0.7)
    score *= agent_confidence

    # Apply domain specialization bonus
    if agent_name.startswith('development:'):
        score += 0.1
    elif agent_name.startswith('orchestration:'):
        score += 0.15
    elif agent_name.startswith('security:'):
        score += 0.15

    return min(score, 1.0)

def optimize_matrix_for_search(compatibility_matrix):
    """
    Matrix optimization for fast search and lookup
    Reference: agents/master.md.backup (lines 751-763)
    """
    optimized_matrix = {}

    for category, agent_scores in compatibility_matrix.items():
        # Sort agents by score
        sorted_agents = sorted(agent_scores.items(), key=lambda x: x[1], reverse=True)
        optimized_matrix[category] = {
            'sorted_agents': sorted_agents,
            'all_scores': agent_scores,
            'top_agents': [agent for agent, score in sorted_agents if score > 0.3],
            'category_total_score': sum(agent_scores.values())
        }

    return optimized_matrix

def update_scoring_with_compatibility_matrix(agent_data, compatibility_matrix):
    """
    Update agent scoring system with compatibility matrix integration
    """
    enhanced_agents = []

    for agent in agent_data:
        agent_name = agent.get('name')
        detected_category = agent.get('detected_category', 'general')

        # Get compatibility scores from matrix
        compatibility_scores = compatibility_matrix.get(detected_category, {})
        matrix_score = compatibility_scores.get(agent_name, 0.0)

        # Calculate enhanced confidence score
        base_confidence = agent.get('category_confidence', 0.7)
        enhanced_confidence = (base_confidence * 0.6) + (matrix_score * 0.4)

        # Update agent data
        enhanced_agent = agent.copy()
        enhanced_agent['matrix_score'] = matrix_score
        enhanced_agent['enhanced_confidence'] = enhanced_confidence
        enhanced_agent['compatibility_rank'] = determine_compatibility_rank(agent, matrix_score)

        enhanced_agents.append(enhanced_agent)

    return enhanced_agents

def determine_compatibility_rank(agent, score):
    """
    Determine agent compatibility rank based on score and performance
    """
    if score >= 0.8:
        return 'expert'
    elif score >= 0.6:
        return 'proficient'
    elif score >= 0.4:
        return 'competent'
    else:
        return 'learning'

def integrate_competency_matrix_with_agent_discovery():
    """
    Integrate competency matrix system with existing agent discovery
    This should be called during step_4_name_registration
    """
    global COMPETENCY_MATRIX_ENABLED
    COMPETENCY_MATRIX_ENABLED = True

    # This would be called in the agent discovery process
    pass

# Global Variables and Constants
COMPETENCY_MATRIX_ENABLED = False
DOMAIN_SYSTEM_INTEGRATION_ENABLED = True

# Global cache for agent discovery
AGENT_CACHE = {}
NAME_RESOLUTION_CACHE = {}

# Utility Functions for Discovery System
utility_functions: |
  # Configuration Loading Utilities
  def load_config_file(file_path):
      """Load YAML configuration file"""
      try:
          with open(file_path, 'r', encoding='utf-8') as f:
              return yaml.safe_load(f)
      except Exception as e:
          log_error(f"Failed to load config file: {file_path}", error=e)
          return None

  def parse_yaml_content(yaml_string):
      """Parse YAML string to dictionary"""
      try:
          return yaml.safe_load(yaml_string)
      except Exception as e:
          log_error("Failed to parse YAML content", error=e)
          return {}

  # Logging Utilities
  def log_error(message, error=None):
      """Log error message"""
      timestamp = datetime.datetime.now().isoformat()
      error_msg = f"[{timestamp}] ERROR: {message}"
      if error:
          error_msg += f" - {str(error)}"
      print(error_msg)  # Replace with proper logging system

  def log_info(message):
      """Log info message"""
      timestamp = datetime.datetime.now().isoformat()
      print(f"[{timestamp}] INFO: {message}")

  # Cache Utilities
  def save_cache_data(cache_key, data):
      """Save data to cache"""
      try:
          cache_path = f"cache/{cache_key}.json"
          os.makedirs("cache", exist_ok=True)
          with open(cache_path, 'w', encoding='utf-8') as f:
              json.dump(data, f, indent=2)
      except Exception as e:
          log_error(f"Failed to save cache data: {cache_key}", error=e)

  def load_cache_data(cache_key):
      """Load data from cache"""
      try:
          cache_path = f"cache/{cache_key}.json"
          if os.path.exists(cache_path):
              with open(cache_path, 'r', encoding='utf-8') as f:
                  return json.load(f)
      except Exception as e:
          log_error(f"Failed to load cache data: {cache_key}", error=e)
      return None

  # Agent Discovery Utilities
  def get_default_agent_list():
      """Get hardcoded default agent list as fallback"""
      return [
          {
              'name': 'master',
              'source': 'hardcoded',
              'category': 'orchestration',
              'capabilities': ['task-orchestration', 'agent-selection', 'coordination'],
              'confidence': 1.0,
              'is_default': True
          }
      ]

  def validate_agent_structure(agent):
      """Validate agent has required structure"""
      required_fields = ['name', 'source', 'category']
      return all(field in agent for field in required_fields)

# Required imports for the system
required_imports: |
  import os
  import glob
  import json
  import yaml
  import datetime
  import pathlib

# Core Discovery Functions Implementation
discovery_functions:

  load_agent_registry: |
    # Load Agent Registry Function
    def load_agent_registry():
        """
        Load agents from registry configuration files
        Returns list of registered agents with metadata
        """
        registry_agents = []

        # Load from config/agent_types.yaml if exists
        try:
            agent_types_config = load_config_file("config/agent_types.yaml")
            if agent_types_config and 'agent_types' in agent_types_config:
                for agent_type, config in agent_types_config['agent_types'].items():
                    agent_data = {
                        'name': agent_type,
                        'source': 'registry',
                        'category': config.get('category', 'general'),
                        'capabilities': config.get('capabilities', []),
                        'triggers': config.get('triggers', []),
                        'tools': config.get('tools', []),
                        'confidence': config.get('confidence', 0.8)
                    }
                    registry_agents.append(agent_data)
        except Exception as e:
            log_error("Failed to load agent registry", error=e)

        return registry_agents

  scan_agent_files: |
    # Scan Agent Files Function
    def scan_agent_files(search_paths):
        """
        Scan specified paths for agent files
        search_paths: list of directories to scan
        Returns list of discovered agents
        """
        discovered_agents = []

        for path in search_paths:
            try:
                if os.path.exists(path):
                    for file_path in glob.glob(f"{path}/*.md"):
                        agent_data = parse_agent_file(file_path)
                        if agent_data:
                            discovered_agents.append(agent_data)
            except Exception as e:
                log_error(f"Failed to scan path: {path}", error=e)

        return discovered_agents

    def parse_agent_file(file_path):
        """
        Parse agent markdown file to extract metadata
        Returns agent data dict or None if invalid
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract YAML frontmatter
            if content.startswith('---'):
                yaml_end = content.find('---', 3)
                if yaml_end > 0:
                    yaml_content = content[3:yaml_end].strip()
                    frontmatter = parse_yaml_content(yaml_content)

                    return {
                        'name': frontmatter.get('name', os.path.basename(file_path)),
                        'source': 'filesystem',
                        'file_path': file_path,
                        'category': frontmatter.get('category', 'general'),
                        'capabilities': frontmatter.get('capabilities', []),
                        'triggers': frontmatter.get('triggers', []),
                        'tools': frontmatter.get('tools', []),
                        'confidence': frontmatter.get('confidence', 0.7)
                    }
        except Exception as e:
            log_error(f"Failed to parse agent file: {file_path}", error=e)

        return None

  merge_agent_sources: |
    # Merge Agent Sources Function
    def merge_agent_sources(registry_agents, filesystem_agents):
        """
        Merge agents from registry and filesystem, remove duplicates
        Returns unified list of agents
        """
        all_agents = []
        seen_agents = set()

        # Add registry agents first (higher priority)
        for agent in registry_agents:
            agent_key = f"{agent['source']}:{agent['name']}"
            if agent_key not in seen_agents:
                all_agents.append(agent)
                seen_agents.add(agent_key)

        # Add filesystem agents (avoid duplicates)
        for agent in filesystem_agents:
            agent_key = f"{agent['source']}:{agent['name']}"
            if agent_key not in seen_agents:
                all_agents.append(agent)
                seen_agents.add(agent_key)

        return all_agents

  validate_agent_list: |
    # Validate Agent List Function
    def validate_agent_list(agents):
        """
        Validate list of agents for completeness and correctness
        Returns list of valid agents
        """
        valid_agents = []

        for agent in agents:
            try:
                if is_registry_agent(agent):
                    if validate_registry_agent(agent):
                        valid_agents.append(agent)
                elif is_system_agent(agent):
                    if validate_system_agent(agent):
                        valid_agents.append(agent)
            except Exception as e:
                log_error(f"Failed to validate agent: {agent.get('name', 'unknown')}", error=e)

        return valid_agents

  agent_type_checkers: |
    # Agent Type Checker Functions
    def is_registry_agent(agent):
        """Check if agent is from registry"""
        return agent.get('source') == 'registry' and ':' in agent.get('name', '')

    def is_system_agent(agent):
        """Check if agent is from filesystem/system"""
        return agent.get('source') in ['filesystem', 'system']

    def validate_registry_agent(agent):
        """Validate registry agent format"""
        required_fields = ['name', 'category', 'capabilities']
        return all(field in agent and agent[field] for field in required_fields)

    def validate_system_agent(agent):
        """Validate system agent format"""
        required_fields = ['name', 'file_path']
        return all(field in agent and agent[field] for field in required_fields)

  search_and_cache_functions: |
    # Search and Cache Functions
    def find_agent_by_name(agent_name, available_agents):
        """
        Find agent by name in available agents list
        Returns agent dict or None if not found
        """
        for agent in available_agents:
            if agent.get('name') == agent_name:
                return agent

        # Try cached resolution
        cached_name = get_cached_name_resolution(agent_name)
        if cached_name:
            for agent in available_agents:
                if agent.get('name') == cached_name:
                    return agent

        return None

    def cache_agent_list(agents):
        """
        Cache agent list for performance
        """
        try:
            cache_data = {
                'agents': agents,
                'timestamp': datetime.datetime.now().isoformat(),
                'count': len(agents)
            }
            save_cache_data('agent_list_cache', cache_data)
        except Exception as e:
            log_error("Failed to cache agent list", error=e)

    def get_cached_name_resolution(agent_name):
        """
        Get cached name resolution for agent
        Returns resolved name or None
        """
        try:
            cache_data = load_cache_data('name_resolution_cache')
            if cache_data:
                return cache_data.get(agent_name)
        except Exception as e:
            log_error(f"Failed to get cached name resolution for {agent_name}", error=e)

        return None

    def cache_name_resolution(agent_name, dynamic_name):
        """
        Cache name resolution mapping
        """
        try:
            cache_data = load_cache_data('name_resolution_cache') or {}
            cache_data[agent_name] = dynamic_name
            save_cache_data('name_resolution_cache', cache_data)
        except Exception as e:
            log_error(f"Failed to cache name resolution {agent_name} -> {dynamic_name}", error=e)

# Filesystem-based Discovery Integration
discovery_integration:
  primary_source:
    method: "filesystem_scan"
    directories: ["agents/", "subagents/"]
    file_pattern: "*.md"
    extraction: "yaml_frontmatter_parsing"

  additional_sources:
    - directory: ".claude/agents/"
      file_pattern: "*.md"
      extraction: "frontmatter_parsing"
      required: false
    - directory: "~/.claude/agents/"
      file_pattern: "*.md"
      extraction: "frontmatter_parsing"
      required: false

# Validation Rules
validation_rules:
  # Filesystem-based Agents (from YAML frontmatter)
  filesystem_agents:
    name_format:
      pattern: "simple-name"  # Name from YAML frontmatter
      required_separator: "none"
      source: "yaml_frontmatter"

    required_fields: ["name", "description", "version"]
    optional_fields: ["triggers", "tools", "capabilities", "category"]

    category_validation:
      allowed_categories: ["engineering", "analysis", "management", "quality", "architecture", "research", "development", "infrastructure", "orchestration"]

    format_validation:
      yaml_frontmatter_required: true
      markdown_content_required: true

  # Fallback validation for missing information
  fallback_validation:
    auto_generate_missing: true
    default_values:
      version: "0.0.1"
      category: "general"
      capabilities: ["basic_functionality"]
      availability: "available"

# Caching System
caching_system:
  cache_type: "memory"
  cache_duration: "session_lifetime"
  invalidation_triggers:
    - "registry_file_change"
    - "filesystem_change"
    - "agent_availability_change"

  cache_structure:
    agent_list: "list_of_agent_objects"
    last_updated: "timestamp"
    source_hash: "file_integrity_hash"

# Error Handling
error_handling:
  invalid_agent_name:
    action: "suggest_alternatives"
    source: "available_agents_cache"
    message_template: "Agent '{name}' not found. Available: {alternatives}"

  no_agents_found:
    action: "create_fallback_agent"
    fallback_agent:
      name: "master"
      description: "Master orchestration agent"
      category: "orchestration"
      capabilities: ["task-orchestration", "agent-selection"]

  filesystem_scan_failure:
    action: "use_hardcoded_agents"
    hardcoded_agents:
      - name: "master"
        type: "orchestration"
        capabilities: ["task-orchestration", "coordination"]

  validation_failure:
    action: "skip_invalid_agent"
    log_level: "warning"
    continue_processing: true

# Performance Optimization
performance_optimization:
  parallel_scanning:
    enabled: true
    max_concurrent_scans: 5

  incremental_updates:
    enabled: true
    track_file_changes: true

  precomputed_indices:
    enabled: true
    index_types: ["name", "category", "capabilities"]

# Integration Points
integration_points:
  master_agent:
    call_point: "agent_selection_phase"
    method: "get_available_agents()"
    refresh_interval: "on_demand"

  task_delegation:
    call_point: "before_task_routing"
    validation_required: true
    fallback_behavior: "suggest_alternatives"

  parallel_execution:
    call_point: "agent_coordination"
    validation_scope: "all_selected_agents"
    error_handling: "fail_fast_on_invalid"

# Monitoring and Metrics
monitoring:
  discovery_metrics:
    - "discovery_time_ms"
    - "agents_discovered_count"
    - "validation_success_rate"
    - "cache_hit_rate"

  performance_metrics:
    - "agent_loading_time"
    - "validation_processing_time"
    - "cache_efficiency"
    - "error_recovery_time"

# Configuration Updates
configuration_updates:
  auto_reload:
    enabled: true
    trigger: "file_system_change"

  manual_reload:
    command: "reload_agent_discovery"
    effect: "clear_cache_and_rediscover"

  cache_invalidation:
    triggers: ["agent_status_change", "filesystem_modification", "configuration_change"]