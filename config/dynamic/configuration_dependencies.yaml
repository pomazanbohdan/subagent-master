# Configuration Dependencies System
# Intelligent dependency resolution for configuration loading

metadata:
  name: "configuration-dependencies"
  version: "0.2.0"
  description: "Configuration dependency resolution system with topological sorting"
  author: "Master Agent System v0.2.0"

# Dependency Graph Configuration
dependency_graph:
  # Configuration Files and Their Dependencies
  configurations:
    # Core Foundation (Level 0 - No dependencies)
    config/core/unified_error_handling.yaml:
      level: 0
      dependencies: []
      priority: "critical"
      load_timeout: 5000
      retry_count: 3

    config/core/sequenced_initialization.yaml:
      level: 0
      dependencies: []
      priority: "critical"
      load_timeout: 3000
      retry_count: 2

    # Knowledge Base (Level 1 - Depends on Core)
    config/knowledge-base/task-analysis.yaml:
      level: 1
      dependencies: ["config/core/unified_error_handling.yaml"]
      priority: "high"
      load_timeout: 8000
      retry_count: 3

    config/knowledge-base/unified_agent_selection.yaml:
      level: 1
      dependencies: ["config/core/unified_error_handling.yaml"]
      priority: "high"
      load_timeout: 6000
      retry_count: 2

    config/knowledge-base/categorization-engine.yaml:
      level: 1
      dependencies: ["config/knowledge-base/task-analysis.yaml"]
      priority: "high"
      load_timeout: 7000
      retry_count: 2

    config/knowledge-base/clarification_system.yaml:
      level: 1
      dependencies: ["config/knowledge-base/task-analysis.yaml"]
      priority: "medium"
      load_timeout: 5000
      retry_count: 2

    config/knowledge-base/tfidf-system.yaml:
      level: 1
      dependencies: ["config/knowledge-base/task-analysis.yaml"]
      priority: "medium"
      load_timeout: 6000
      retry_count: 2

    config/knowledge-base/parallel_coordination.yaml:
      level: 1
      dependencies: ["config/core/unified_error_handling.yaml"]
      priority: "medium"
      load_timeout: 5000
      retry_count: 2

    config/knowledge-base/todo_execution_engine.yaml:
      level: 1
      dependencies: ["config/knowledge-base/task-analysis.yaml"]
      priority: "medium"
      load_timeout: 4000
      retry_count: 2

    # Rules (Level 1 - Depends on Core)
    config/rules/parallel_execution_rules.yaml:
      level: 1
      dependencies: ["config/core/unified_error_handling.yaml"]
      priority: "high"
      load_timeout: 4000
      retry_count: 2

    # Dynamic Configuration (Level 2 - Depends on Knowledge Base)
    config/dynamic/agent_types.yaml:
      level: 2
      dependencies: [
        "config/knowledge-base/unified_agent_selection.yaml",
        "config/knowledge-base/categorization-engine.yaml"
      ]
      priority: "critical"
      load_timeout: 10000
      retry_count: 3

    config/dynamic/dynamic_agent_discovery.yaml:
      level: 2
      dependencies: [
        "config/dynamic/agent_types.yaml",
        "config/knowledge-base/categorization-engine.yaml",
        "config/knowledge-base/tfidf-system.yaml"
      ]
      priority: "critical"
      load_timeout: 12000
      retry_count: 3

    config/dynamic/mcp_registry.yaml:
      level: 2
      dependencies: [
        "config/dynamic/dynamic_agent_discovery.yaml",
        "config/core/unified_error_handling.yaml"
      ]
      priority: "high"
      load_timeout: 8000
      retry_count: 2

    config/dynamic/domain_system.yaml:
      level: 2
      dependencies: [
        "config/dynamic/dynamic_agent_discovery.yaml",
        "config/knowledge-base/categorization-engine.yaml"
      ]
      priority: "high"
      load_timeout: 10000
      retry_count: 2

    # Additional Dynamic Configs (Level 3 - Depends on previous Dynamic)
    config/dynamic/config_loader.yaml:
      level: 3
      dependencies: [
        "config/dynamic/agent_types.yaml",
        "config/dynamic/mcp_registry.yaml",
        "config/dynamic/domain_system.yaml"
      ]
      priority: "high"
      load_timeout: 6000
      retry_count: 2

    config/dynamic/performance_tracking.yaml:
      level: 3
      dependencies: [
        "config/dynamic/config_loader.yaml",
        "config/dynamic/mcp_registry.yaml"
      ]
      priority: "medium"
      load_timeout: 5000
      retry_count: 2

    config/dynamic/time_estimation.yaml:
      level: 3
      dependencies: [
        "config/dynamic/performance_tracking.yaml",
        "config/knowledge-base/task-analysis.yaml"
      ]
      priority: "medium"
      load_timeout: 4000
      retry_count: 2

    config/dynamic/runtime_environment.yaml:
      level: 3
      dependencies: [
        "config/dynamic/config_loader.yaml",
        "config/core/sequenced_initialization.yaml"
      ]
      priority: "medium"
      load_timeout: 6000
      retry_count: 2

    config/dynamic/variable_management.yaml:
      level: 3
      dependencies: [
        "config/dynamic/runtime_environment.yaml",
        "config/dynamic/config_loader.yaml"
      ]
      priority: "low"
      load_timeout: 4000
      retry_count: 1

    config/dynamic/unified_metrics.yaml:
      level: 3
      dependencies: [
        "config/dynamic/performance_tracking.yaml",
        "config/dynamic/time_estimation.yaml"
      ]
      priority: "low"
      load_timeout: 5000
      retry_count: 1

    config/dynamic/integrated_environment_config.yaml:
      level: 4
      dependencies: [
        "config/dynamic/runtime_environment.yaml",
        "config/dynamic/variable_management.yaml",
        "config/dynamic/unified_metrics.yaml"
      ]
      priority: "low"
      load_timeout: 7000
      retry_count: 1

    config/dynamic/agent_name_resolution.yaml:
      level: 2
      dependencies: [
        "config/dynamic/dynamic_agent_discovery.yaml",
        "config/knowledge-base/categorization-engine.yaml"
      ]
      priority: "high"
      load_timeout: 6000
      retry_count: 2

# Loading Strategy Configuration
loading_strategy:
  # Topological Sorting Algorithm
  topological_sort:
    algorithm: "kahn_algorithm"
    detect_cycles: true
    cycle_resolution: "error_with_suggestions"

  # Parallel Loading Configuration
  parallel_loading:
    enabled: true
    max_concurrent_loaders: 4
    level_based_parallelism: true

    # Load configurations by dependency level
    level_loading:
      level_0: 1  # Sequential - critical foundation
      level_1: 2  # Parallel  - knowledge base + rules
      level_2: 3  # Parallel  - dynamic configurations
      level_3: 4  # Parallel  - extended dynamic configs
      level_4: 2  # Parallel  - integration configs

  # Dependency Validation
  dependency_validation:
    enabled: true
    strict_validation: true
    missing_dependency_action: "error"
    circular_dependency_action: "error"

  # Error Handling and Recovery
  error_handling:
    retry_strategy: "exponential_backoff"
    retry_base_delay: 1000  # milliseconds
    retry_max_delay: 10000  # milliseconds

    failure_handling:
      critical_dependency_failure: "abort_initialization"
      non_critical_dependency_failure: "continue_with_warnings"
      partial_failure_recovery: "attempt_best_effort_loading"

    rollback_strategy:
      enabled: true
      rollback_on_failure: true
      cleanup_partial_loads: true

# Topological Sort Implementation
topological_sort_algorithm: |
  # Topological Sort Implementation using Kahn's Algorithm
  def topological_sort_dependencies(configurations):
      """
      Sort configurations based on dependencies using topological sort

      Args:
          configurations: Dict of configuration paths to their metadata

      Returns:
          List of configuration paths in dependency order
          List of dependency levels for parallel loading
      """

      # Build adjacency list and in-degree count
      adjacency_list = {}
      in_degree = {}
      all_configs = set()

      for config_path, metadata in configurations.items():
          all_configs.add(config_path)
          adjacency_list[config_path] = []
          in_degree[config_path] = 0

          # Add edges for dependencies
          for dependency in metadata.get('dependencies', []):
              if dependency in configurations:
                  adjacency_list[dependency].append(config_path)
                  in_degree[config_path] += 1

      # Initialize queue with nodes having no dependencies
      queue = []
      for config in all_configs:
          if in_degree[config] == 0:
              queue.append(config)

      # Process nodes in topological order
      sorted_configs = []
      levels = {}

      while queue:
          # Group by level for parallel processing
          current_level = len(sorted_configs)
          level_configs = queue.copy()
          queue.clear()

          for config in level_configs:
              sorted_configs.append(config)
              levels[config] = current_level

              # Update neighbors
              for neighbor in adjacency_list[config]:
                  in_degree[neighbor] -= 1
                  if in_degree[neighbor] == 0:
                      queue.append(neighbor)

      # Check for circular dependencies
      if len(sorted_configs) != len(all_configs):
          remaining_configs = all_configs - set(sorted_configs)
          raise CircularDependencyError(
              f"Circular dependency detected among: {remaining_configs}"
          )

      return sorted_configs, levels

  def generate_loading_plan(levels, max_parallel_loaders):
      """
      Generate optimal loading plan based on dependency levels
      """
      # Group configurations by level
      level_groups = {}
      for config, level in levels.items():
          if level not in level_groups:
              level_groups[level] = []
          level_groups[level].append(config)

      # Sort levels
      sorted_levels = sorted(level_groups.keys())

      # Generate loading batches
      loading_batches = []
      for level in sorted_levels:
          configs = level_groups[level]

          # Split large levels into batches based on parallel loader limit
          if len(configs) <= max_parallel_loaders:
              loading_batches.append({
                  'level': level,
                  'configs': configs,
                  'parallel': True
              })
          else:
              # Split into multiple batches
              for i in range(0, len(configs), max_parallel_loaders):
                  batch_configs = configs[i:i + max_parallel_loaders]
                  loading_batches.append({
                      'level': level,
                      'configs': batch_configs,
                      'parallel': True
                  })

      return loading_batches

# Dependency Resolution Engine
dependency_resolution_engine: |
  # Dependency Resolution Engine
  class ConfigurationDependencyResolver:
      def __init__(self, dependency_config):
          self.dependency_config = dependency_config
          self.loading_strategy = dependency_config['loading_strategy']
          self.configurations = dependency_config['dependency_graph']['configurations']

      def resolve_dependencies(self):
          """
          Resolve configuration dependencies and create loading plan
          """
          try:
              # Perform topological sort
              sorted_configs, levels = self._topological_sort()

              # Generate loading plan
              loading_plan = self._generate_loading_plan(levels)

              # Validate loading plan
              self._validate_loading_plan(loading_plan)

              return {
                  'status': 'success',
                  'sorted_configurations': sorted_configs,
                  'dependency_levels': levels,
                  'loading_plan': loading_plan,
                  'parallel_loading_enabled': self.loading_strategy['parallel_loading']['enabled']
              }

          except CircularDependencyError as e:
              return {
                  'status': 'error',
                  'error_type': 'circular_dependency',
                  'message': str(e),
                  'suggestions': self._suggest_cycle_resolution()
              }
          except MissingDependencyError as e:
              return {
                  'status': 'error',
                  'error_type': 'missing_dependency',
                  'message': str(e),
                  'suggestions': self._suggest_dependency_resolution()
              }
          except Exception as e:
              return {
                  'status': 'error',
                  'error_type': 'unexpected_error',
                  'message': str(e),
                  'suggestions': ['Check configuration syntax', 'Verify file paths exist']
              }

      def _topological_sort(self):
          """Implementation of topological sort algorithm"""
          # Implementation would go here
          pass

      def _generate_loading_plan(self, levels):
          """Generate optimal loading plan"""
          # Implementation would go here
          pass

      def _validate_loading_plan(self, loading_plan):
          """Validate the generated loading plan"""
          # Implementation would go here
          pass

      def _suggest_cycle_resolution(self):
          """Suggest resolutions for circular dependencies"""
          return [
              "Review configuration dependencies for cycles",
              "Consider merging circularly dependent configurations",
              "Review if all dependencies are actually required"
          ]

      def _suggest_dependency_resolution(self):
          """Suggest resolutions for missing dependencies"""
          return [
              "Check if dependency files exist",
              "Verify file paths are correct",
              "Review if dependency can be made optional"
              ]

# Loading Orchestration
loading_orchestration: |
  # Configuration Loading Orchestrator
  class ConfigurationLoader:
      def __init__(self, dependency_resolver, loading_config):
          self.dependency_resolver = dependency_resolver
          self.loading_config = loading_config
          self.loading_strategy = loading_config['loading_strategy']

      def load_configurations(self):
          """
          Load configurations based on resolved dependencies
          """
          # Resolve dependencies
          resolution_result = self.dependency_resolver.resolve_dependencies()

          if resolution_result['status'] != 'success':
              raise ConfigurationError(
                  f"Dependency resolution failed: {resolution_result['message']}"
              )

          loading_plan = resolution_result['loading_plan']
          loaded_configurations = {}

          # Execute loading plan
          for batch in loading_plan:
              batch_result = self._load_configuration_batch(batch)

              if batch_result['status'] != 'success':
                  if self.loading_strategy['error_handling']['failure_handling']['critical_dependency_failure'] == 'abort_initialization':
                      raise ConfigurationError(
                          f"Critical loading failure in batch {batch['level']}: {batch_result['message']}"
                      )
                  else:
                      # Continue with warnings for non-critical failures
                      self._log_warning(f"Batch {batch['level']} partially failed: {batch_result['message']}")

              # Merge successfully loaded configurations
              loaded_configurations.update(batch_result['loaded_configurations'])

          return {
              'status': 'success',
              'loaded_configurations': loaded_configurations,
              'loading_summary': self._generate_loading_summary(loading_plan)
          }

      def _load_configuration_batch(self, batch):
          """Load a batch of configurations (parallel or sequential)"""
          if batch['parallel'] and self.loading_strategy['parallel_loading']['enabled']:
              return self._load_parallel_batch(batch)
          else:
              return self._load_sequential_batch(batch)

      def _load_parallel_batch(self, batch):
          """Load configurations in parallel"""
          import concurrent.futures

          loaded_configs = {}
          errors = []

          max_workers = min(
              self.loading_strategy['parallel_loading']['max_concurrent_loaders'],
              len(batch['configs'])
          )

          with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
              # Submit all loading tasks
              future_to_config = {
                  executor.submit(self._load_single_configuration, config_path): config_path
                  for config_path in batch['configs']
              }

              # Collect results
              for future in concurrent.futures.as_completed(future_to_config):
                  config_path = future_to_config[future]
                  try:
                      config_data = future.result(timeout=30)  # 30 second timeout per config
                      loaded_configs[config_path] = config_data
                  except Exception as e:
                      errors.append({
                          'config_path': config_path,
                          'error': str(e),
                          'error_type': type(e).__name__
                      })

          return {
              'status': 'success' if not errors else 'partial_success',
              'loaded_configurations': loaded_configs,
              'errors': errors,
              'batch_level': batch['level']
          }

      def _load_sequential_batch(self, batch):
          """Load configurations sequentially"""
          loaded_configs = {}
          errors = []

          for config_path in batch['configs']:
              try:
                  config_data = self._load_single_configuration(config_path)
                  loaded_configs[config_path] = config_data
              except Exception as e:
                  errors.append({
                      'config_path': config_path,
                      'error': str(e),
                      'error_type': type(e).__name__
                  })

                  # Determine if we should continue
                  if self._should_abort_on_error(config_path):
                      break

          return {
              'status': 'success' if not errors else 'partial_success',
              'loaded_configurations': loaded_configs,
              'errors': errors,
              'batch_level': batch['level']
          }

# Monitoring and Validation
monitoring_system:
  # Loading Metrics
  loading_metrics:
    track_metrics: true
    metrics_to_track:
      - "dependency_resolution_time"
      - "configuration_loading_time"
      - "parallel_loading_efficiency"
      - "error_recovery_time"
      - "memory_usage"

    alert_thresholds:
      dependency_resolution_time: 5000  # milliseconds
      configuration_loading_time: 30000  # milliseconds
      error_rate: 0.1  # 10%
      memory_usage: 512  # MB

  # Validation Rules
  validation_rules:
    dependency_validation:
      check_circular_dependencies: true
      check_missing_dependencies: true
      validate_dependency_levels: true

    configuration_validation:
      validate_yaml_syntax: true
      validate_required_fields: true
      validate_configuration_schema: true

    loading_validation:
      validate_loading_order: true
      validate_parallel_execution: true
      validate_error_handling: true

# Error Definitions
error_definitions:
  CircularDependencyError:
    description: "Circular dependency detected in configuration loading"
    handling_strategy: "error_with_resolution_suggestions"

  MissingDependencyError:
    description: "Required configuration dependency is missing"
    handling_strategy: "error_with_fallback_suggestions"

  ConfigurationLoadError:
    description: "Failed to load configuration file"
    handling_strategy: "retry_with_backoff"

  ValidationError:
    description: "Configuration validation failed"
    handling_strategy: "log_warning_and_continue"