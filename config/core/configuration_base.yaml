# Configuration Base System
# Dependency-aware configuration loading with topological sorting and resource management

metadata:
  name: "configuration_base"
  version: "0.3.0"
  description: "Configuration base system with dependency resolution, loading, and resource management"
  author: "Master Agent System"
  tags: ["configuration", "dependency-resolution", "loading", "topological-sort", "resource-management"]

# Phase-Based Dependency Graph (Optimized v0.3.0 Architecture)
dependency_graph:
  # Optimized Architecture Configuration Files and Their Dependencies
  configurations:
    # Phase 0: MCP Discovery & Core Setup (Parallel Loading)
    config/core/mcp_server_discovery.yaml:
      phase: 0
      dependencies: []
      priority: "critical"
      load_timeout: 30000
      retry_count: 3
      description: "MCP Server Discovery and Validation system (Phase 0 prerequisite)"

    config/core/error_handling_initialization.yaml:
      phase: 0
      dependencies: []
      priority: "critical"
      load_timeout: 15000
      retry_count: 3
      description: "Enhanced error handling and initialization system with MCP integration"

    config/core/monitoring_system.yaml:
      phase: 0
      dependencies: []
      priority: "high"
      load_timeout: 10000
      retry_count: 3
      description: "Centralized monitoring system orchestration for unified metrics and performance analytics"

    # Phase 1: Analysis & Selection Systems (Parallel Loading)
    config/analysis/task_analysis.yaml:
      phase: 1
      dependencies: ["config/core/mcp_server_discovery.yaml", "config/core/error_handling_initialization.yaml"]
      priority: "critical"
      load_timeout: 8000
      retry_count: 3
      description: "Enhanced task analysis with MCP integration"

    config/analysis/agent_selection.yaml:
      phase: 1
      dependencies: ["config/core/mcp_server_discovery.yaml", "config/core/error_handling_initialization.yaml"]
      priority: "critical"
      load_timeout: 6000
      retry_count: 2
      description: "Ultimate agent selection with TF-IDF and MCP integration"

    # Phase 2: Clarification & Advanced Processing (Sequential)
    config/analysis/clarification.yaml:
      phase: 2
      dependencies: [
        "config/analysis/task_analysis.yaml",
        "config/analysis/agent_selection.yaml",
        "config/core/mcp_server_discovery.yaml"
      ]
      priority: "medium"
      load_timeout: 8000  # Increased for fallback system
      retry_count: 3      # Increased retry count
      fallback_enabled: true
      description: "Enhanced clarification with MCP tool awareness and graceful degradation fallback system"

    # Phase 3: Execution & Coordination (Parallel Loading)
    config/execution/todo_engine.yaml:
      phase: 3
      dependencies: [
        "config/analysis/task_analysis.yaml",
        "config/analysis/agent_selection.yaml",
        "config/core/mcp_server_discovery.yaml"
      ]
      priority: "critical"
      load_timeout: 6000
      retry_count: 3
      description: "Enhanced TODO execution engine with MCP integration"

    config/execution/delegation.yaml:
      phase: 3
      dependencies: ["config/execution/todo_engine.yaml", "config/core/mcp_server_discovery.yaml"]
      priority: "high"
      load_timeout: 5000
      retry_count: 2
      description: "Enhanced delegation with MCP tool integration"

    config/execution/coordination.yaml:
      phase: 3
      dependencies: ["config/core/error_handling_initialization.yaml", "config/core/mcp_server_discovery.yaml"]
      priority: "high"
      load_timeout: 5000
      retry_count: 2
      description: "Enhanced parallel coordination with MCP support"

    # Phase 4: Discovery & Orchestration (Parallel Loading)
    config/discovery/agent_registry.yaml:
      phase: 4
      dependencies: [
        "config/core/mcp_server_discovery.yaml",
        "config/execution/delegation.yaml",
        "config/analysis/task_analysis.yaml",
        "config/analysis/agent_selection.yaml"
      ]
      priority: "high"
      load_timeout: 8000
      retry_count: 3
      description: "Dynamic agent discovery with comprehensive MCP integration"

    config/orchestration/batch_orchestrator.yaml:
      phase: 4
      dependencies: ["config/execution/coordination.yaml"]
      priority: "high"
      load_timeout: 6000
      retry_count: 2
      description: "Unified batch orchestration system for parallel operations"

# Enhanced Loading Strategy Configuration
loading_strategy:
  # Topological Sorting Algorithm
  topological_sort:
    algorithm: "kahn_algorithm"
    detect_cycles: true
    cycle_resolution: "error_with_suggestions"
    validation_enabled: true

  # Enhanced Parallel Loading Configuration
  parallel_loading:
    enabled: true
    max_concurrent_loaders: 6  # Optimized for new architecture
    level_based_parallelism: true
    adaptive_resource_management: true

    # Thread Pool Configuration for Consolidated Architecture
    thread_pools:
      io_operations:
        pool_size: 8      # Reduced from 12 due to consolidation
        queue_size: 100
        thread_name_prefix: "config-loader-io"
        keep_alive_time: 60

      cpu_operations:
        pool_size: 4      # Optimized for new dependency levels
        queue_size: 50
        thread_name_prefix: "config-loader-cpu"
        keep_alive_time: 30

      priority_operations:
        pool_size: 2
        queue_size: 20
        thread_name_prefix: "config-loader-priority"
        keep_alive_time: 120

    # Resource Monitoring and Adaptive Configuration
    resource_monitoring:
      enabled: true
      memory_threshold_mb: 512  # Reduced due to consolidation efficiency
      cpu_threshold_percent: 75  # Slightly reduced due to optimization
      adjustment_factor: 0.8
      adaptive_scaling: true

    # Load configurations by phase (optimized for clean 5-phase architecture)
    phase_loading:
      phase_0: 3   # Parallel - MCP discovery & core setup (mcp_server_discovery, error_handling_initialization, monitoring_system)
      phase_1: 2   # Parallel - analysis & selection systems (task_analysis, agent_selection)
      phase_2: 1   # Sequential - clarification & advanced processing (clarification)
      phase_3: 3   # Parallel - execution & coordination (todo_engine, delegation, coordination)
      phase_4: 2   # Parallel - discovery & orchestration (agent_registry, batch_orchestrator)

  # Enhanced Adaptive Timeout Configuration
  adaptive_timeouts:
    enabled: true
    base_timeout_ms: 3000
    max_timeout_ms: 25000  # Reduced due to consolidation efficiency
    complexity_multiplier: 1.1  # Reduced due to simplified dependencies
    resource_adjustment: true

    # Priority-based timeout adjustment (optimized)
    priority_timeout_factors:
      critical: 0.8   # 20% faster timeout for critical configs
      high: 1.0       # Standard timeout
      medium: 1.2     # 20% longer timeout
      low: 1.4        # 40% longer timeout

    # System load-based timeout adjustment
    load_based_adjustment:
      enabled: true
      cpu_thresholds:
        light_load: 50     # < 50% CPU usage, reduce timeout by 15%
        medium_load: 75    # 50-75% CPU usage, standard timeout
        heavy_load: 90     # 75-90% CPU usage, increase timeout by 30%
        extreme_load: 100  # > 90% CPU usage, increase timeout by 60%

  # Dependency Validation (Enhanced)
  dependency_validation:
    enabled: true
    strict_validation: true
    missing_dependency_action: "error"
    circular_dependency_action: "error"
    validation_timeout: 5000
    cache_validation_results: true

  # Error Handling and Recovery (Consolidated)
  error_handling:
    retry_strategy: "exponential_backoff"
    retry_base_delay: 1000
    retry_max_delay: 8000  # Reduced due to consolidation efficiency
    max_retry_attempts: 3

    failure_handling:
      critical_dependency_failure: "abort_initialization"
      non_critical_dependency_failure: "continue_with_warnings"
      partial_failure_recovery: "attempt_best_effort_loading"
      cascade_failure_prevention: true
      clarification_dependency_failure: "activate_fallback_mode"

    rollback_strategy:
      enabled: true
      rollback_on_failure: true
      cleanup_partial_loads: true
      preserve_successful_loads: true

    dependency_failure_handling:
      task_analysis_unavailable_for_clarification:
        action: "activate_clarification_fallback"
        logging: "log_task_analysis_dependency_failure"
        continue_initialization: true
        fallback_mode: "degraded_clarification"

      multiple_dependencies_unavailable:
        action: "emergency_mode_activation"
        logging: "log_multiple_system_failures"
        continue_initialization: true
        fallback_mode: "emergency_clarification"

      recovery_mechanisms:
        automatic_retry: true
        periodic_health_checks: true
        graceful_degradation: true
        user_notification: true

# Enhanced Topological Sort Implementation
topological_sort_algorithm: |
  # Enhanced Topological Sort for 5-Phase Architecture v0.3.0
  def topological_sort_dependencies_v3(configurations):
      """
      Sort configurations based on dependencies using topological sort
      Optimized for the 5-phase enhanced architecture with MCP Server Discovery

      Args:
          configurations: Dict of configuration paths to their metadata

      Returns:
          List of configuration paths in dependency order
          Dict of dependency levels for parallel loading
          Loading plan optimized for enhanced 5-phase architecture
      """

      # Build adjacency list and in-degree count
      adjacency_list = {}
      in_degree = {}
      all_configs = set()
      config_metadata = {}

      for config_path, metadata in configurations.items():
          all_configs.add(config_path)
          config_metadata[config_path] = metadata
          adjacency_list[config_path] = []
          in_degree[config_path] = 0

          # Add edges for dependencies (consolidated paths)
          for dependency in metadata.get('dependencies', []):
              if dependency in configurations:
                  adjacency_list[dependency].append(config_path)
                  in_degree[config_path] += 1

      # Initialize queue with nodes having no dependencies
      queue = []
      for config in all_configs:
          if in_degree[config] == 0:
              queue.append(config)

      # Process nodes in topological order
      sorted_configs = []
      levels = {}

      while queue:
          # Group by level for parallel processing (optimized for 5 levels)
          current_level = len(sorted_configs)
          level_configs = queue.copy()
          queue.clear()

          for config in level_configs:
              sorted_configs.append(config)
              levels[config] = current_level

              # Update neighbors
              for neighbor in adjacency_list[config]:
                  in_degree[neighbor] -= 1
                  if in_degree[neighbor] == 0:
                      queue.append(neighbor)

      # Check for circular dependencies
      if len(sorted_configs) != len(all_configs):
          remaining_configs = all_configs - set(sorted_configs)
          raise CircularDependencyError(
              f"Circular dependency detected among: {remaining_configs}"
          )

      return sorted_configs, levels, config_metadata

  def generate_optimized_loading_plan(phases, config_metadata, max_parallel_loaders):
      """
      Generate optimal loading plan for clean 5-phase architecture
      """
      # Group configurations by phase (5 phases max)
      phase_groups = {}
      for config, phase in phases.items():
          if phase not in phase_groups:
              phase_groups[phase] = []
          phase_groups[phase].append(config)

      # Sort phases (0 to 4)
      sorted_phases = sorted(phase_groups.keys())

      # Generate loading batches (optimized for clean architecture)
      loading_batches = []
      for phase in sorted_phases:
          configs = phase_groups[phase]

          # Add metadata to batch
          batch_metadata = {
              'phase': phase,
              'configs': configs,
              'parallel': True,  # All phases support parallel loading within phase
              'priority': determine_batch_priority(configs, config_metadata),
              'estimated_timeout': calculate_batch_timeout(configs, config_metadata)
          }

          # Check if batch needs splitting
          if len(configs) <= max_parallel_loaders:
              loading_batches.append(batch_metadata)
          else:
              # Split large batches
              for i in range(0, len(configs), max_parallel_loaders):
                  batch_configs = configs[i:i + max_parallel_loaders]
                  loading_batches.append({
                      **batch_metadata,
                      'configs': batch_configs,
                      'batch_index': i // max_parallel_loaders
                  })

      return loading_batches

  def determine_batch_priority(configs, config_metadata):
      """Determine batch priority based on config priorities"""
      priorities = [config_metadata.get(config, {}).get('priority', 'low') for config in configs]
      if 'critical' in priorities:
          return 'critical'
      elif 'high' in priorities:
          return 'high'
      elif 'medium' in priorities:
          return 'medium'
      else:
          return 'low'

  def calculate_batch_timeout(configs, config_metadata):
      """Calculate appropriate timeout for batch"""
      timeouts = [config_metadata.get(config, {}).get('load_timeout', 5000) for config in configs]
      return max(timeouts) * 1.2  # 20% buffer

# Enhanced Dependency Resolution Engine
dependency_resolution_engine: |
  # Enhanced Dependency Resolution Engine for 5-Phase Architecture v0.3.0
  class EnhancedConfigurationResolver:
      def __init__(self, dependency_config):
          self.dependency_config = dependency_config
          self.loading_strategy = dependency_config['loading_strategy']
          self.configurations = dependency_config['dependency_graph']['configurations']
          self.consolidation_mapping = self._build_consolidation_mapping()

      def _build_consolidation_mapping(self):
          """Build mapping from old to new consolidated paths"""
          return {
              # Core mappings
              'config/core/unified_error_handling.yaml': 'config/core/error_handling_initialization.yaml',
              'config/core/sequenced_initialization.yaml': 'config/core/error_handling_initialization.yaml',
              'config/core/mcp_server_discovery.yaml': 'config/core/mcp_server_discovery.yaml',

              # Analysis mappings
              'config/knowledge-base/task-analysis.yaml': 'config/analysis/task_analysis.yaml',
              'config/knowledge-base/unified_agent_selection.yaml': 'config/analysis/agent_selection.yaml',
              'config/knowledge-base/tfidf-system.yaml': 'config/analysis/agent_selection.yaml',
              'config/knowledge-base/categorization-engine.yaml': 'config/analysis/agent_selection.yaml',
              'config/knowledge-base/clarification_system.yaml': 'config/analysis/clarification.yaml',

              # Execution mappings
              'config/knowledge-base/todo_execution_engine.yaml': 'config/execution/todo_engine.yaml',
              'config/knowledge-base/todo_execution_backup.yaml': 'config/execution/todo_engine.yaml',
              'config/knowledge-base/parallel_coordination.yaml': 'config/execution/coordination.yaml',
              'config/rules/parallel_execution_rules.yaml': 'config/execution/coordination.yaml',
              'config/rules/todo_delegation_rules.yaml': 'config/execution/delegation.yaml',

              # Discovery mappings
              'config/dynamic/agent_types.yaml': 'config/discovery/agent_registry.yaml',
              'config/dynamic/dynamic_agent_discovery.yaml': 'config/discovery/agent_registry.yaml',
              'config/dynamic/agent_name_resolution.yaml': 'config/discovery/agent_registry.yaml',
              'config/core/mcp_integration.yaml': 'config/core/mcp_server_discovery.yaml',
              'config/dynamic/mcp_registry.yaml': 'config/core/mcp_server_discovery.yaml'
          }

      def resolve_enhanced_dependencies(self):
          """
          Resolve dependencies for enhanced 5-phase architecture with MCP integration
          """
          try:
              # Validate consolidation mapping
              self._validate_consolidation_mapping()

              # Perform topological sort
              sorted_configs, levels, config_metadata = self._topological_sort_enhanced()

              # Generate optimized loading plan
              loading_plan = self._generate_enhanced_loading_plan(levels, config_metadata)

              # Validate loading plan
              self._validate_enhanced_loading_plan(loading_plan)

              return {
                  'status': 'success',
                  'sorted_configurations': sorted_configs,
                  'dependency_phases': levels,
                  'loading_plan': loading_plan,
                  'consolidation_mapping': self.consolidation_mapping,
                  'parallel_loading_enabled': self.loading_strategy['parallel_loading']['enabled'],
                  'architecture_version': 'v0.3.0',
                  'total_configurations': len(sorted_configs),
                  'mcp_integration_enabled': True,
                  'phase_count': 5
              }

          except CircularDependencyError as e:
              return {
                  'status': 'error',
                  'error_type': 'circular_dependency',
                  'message': str(e),
                  'suggestions': self._suggest_cycle_resolution(),
                  'architecture_version': 'v0.3.0'
              }
          except Exception as e:
              return {
                  'status': 'error',
                  'error_type': 'resolution_error',
                  'message': str(e),
                  'suggestions': self._suggest_general_resolution(),
                  'architecture_version': 'v0.3.0'
              }

      def _topological_sort_enhanced(self):
          """Enhanced topological sort for 5-phase architecture"""
          # Implementation using the v0.3.0 algorithm
          pass

      def _generate_optimized_loading_plan(self, phases, config_metadata):
          """Generate optimized loading plan for clean 5-phase architecture"""
          return self.generate_optimized_loading_plan(phases, config_metadata, 6)

      def _validate_enhanced_loading_plan(self, loading_plan):
          """Validate enhanced loading plan for 5-phase architecture"""
          # Enhanced validation for MCP integration
          pass

      def _validate_consolidation_mapping(self):
          """Validate that all old configurations have consolidated equivalents"""
          old_configs = set(self.consolidation_mapping.keys())
          new_configs = set(self.consolidation_mapping.values())

          # Check for missing consolidations
          missing_consolidations = old_configs - new_configs
          if missing_consolidations:
              raise ConsolidationValidationError(
                  f"Missing consolidation mappings for: {missing_consolidations}"
              )

      def _calculate_consolidation_ratio(self):
          """Calculate the consolidation improvement ratio"""
          old_count = len(self.consolidation_mapping.keys())
          new_count = len(set(self.consolidation_mapping.values()))
          return {
              'old_file_count': old_count,
              'new_file_count': new_count,
              'reduction_ratio': (old_count - new_count) / old_count,
              'improvement_percentage': ((old_count - new_count) / old_count) * 100
          }

# Performance Metrics and Monitoring (Consolidated)
monitoring_system:
  # Enhanced Loading Metrics
  loading_metrics:
    track_metrics: true
    metrics_to_track:
      - "dependency_resolution_time"
      - "configuration_loading_time"
      - "parallel_loading_efficiency"
      - "consolidation_efficiency"
      - "resource_utilization"
      - "error_recovery_time"
      - "memory_usage"

    # Performance targets for enhanced 5-phase architecture
    performance_targets:
      dependency_resolution_time: 3000   # Improved from 5000ms
      configuration_loading_time: 25000   # Enhanced for MCP integration
      parallel_loading_efficiency: 0.85   # Target 85% efficiency
      consolidation_efficiency: 0.90      # Target 90% efficiency
      memory_usage: 384                    # Increased for MCP integration
      error_rate: 0.05                     # Reduced from 10% to 5%
      mcp_discovery_time: 15000            # New: MCP Server Discovery time
      mcp_validation_time: 10000           # New: MCP validation time

    alert_thresholds:
      dependency_resolution_time: 5000
      configuration_loading_time: 30000
      error_rate: 0.1
      memory_usage: 512
      mcp_discovery_time: 20000
      mcp_validation_time: 15000

  # Validation Rules (Enhanced for 5-Phase Architecture)
  validation_rules:
    dependency_validation:
      check_circular_dependencies: true
      check_missing_dependencies: true
      validate_dependency_phases: true
      validate_consolidation_mapping: true
      validate_mcp_integration: true

    configuration_validation:
      validate_yaml_syntax: true
      validate_required_fields: true
      validate_configuration_schema: true
      validate_consolidation_integrity: true
      validate_mcp_compatibility: true

    loading_validation:
      validate_loading_order: true
      validate_parallel_execution: true
      validate_error_handling: true
      validate_mcp_discovery: true
      validate_enhanced_benefits: true

# Error Definitions (Enhanced for 5-Phase Architecture)
error_definitions:
  CircularDependencyError:
    description: "Circular dependency detected in enhanced configuration loading"
    handling_strategy: "error_with_resolution_suggestions"

  ConsolidationValidationError:
    description: "Error in configuration consolidation mapping or validation"
    handling_strategy: "fallback_to_individual_configs"

  ConfigurationLoadError:
    description: "Failed to load enhanced configuration file"
    handling_strategy: "retry_with_backoff_and_individual_fallback"

  ValidationError:
    description: "Enhanced configuration validation failed"
    handling_strategy: "log_warning_and_continue_with_best_effort"

  MCPDiscoveryError:
    description: "MCP Server Discovery failed or incomplete"
    handling_strategy: "continue_with_basic_mcp_functionality"

  MCPValidationError:
    description: "MCP Server validation failed or compatibility issues"
    handling_strategy: "disable_problematic_mcp_tools"

  MCPIntegrationError:
    description: "MCP integration failed during initialization"
    handling_strategy: "graceful_degradation_with_native_tools"

# Enhanced Configuration Cache System
cache_system:
  enabled: true
  cache_strategy: "intelligent_caching_with_mcp"

  dependency_cache:
    enabled: true
    cache_duration: 3600  # 1 hour
    max_cache_size: 150   # Increased for MCP discovery results

  configuration_cache:
    enabled: true
    cache_duration: 1800  # 30 minutes
    compression_enabled: true
    max_cache_size_mb: 96   # Increased for MCP tool data

  mcp_cache:
    enabled: true
    cache_duration: 900   # 15 minutes for MCP server data
    max_cache_size_mb: 32
    cache_server_capabilities: true
    cache_tool_performance: true

  cache_invalidation:
    on_configuration_change: true
    on_dependency_change: true
    on_error_threshold_exceeded: true
    on_mcp_server_change: true
    on_mcp_tool_discovery: true

# Integration Points (Updated for Enhanced 5-Phase Architecture)
integration_points:
  # Internal Integration
  internal_systems:
    - configuration_base_integrates_with: ["error_handling_initialization", "mcp_server_discovery", "all_other_components"]
    - dependency_resolver_integrates_with: ["monitoring_system", "cache_system", "mcp_validation"]
    - loading_strategy_integrates_with: ["resource_monitoring", "error_handling", "mcp_health_monitoring"]

  # External Integration
  external_systems:
    - analysis_integration: "configuration_base_coordinates_with_analysis_components_with_mcp"
    - execution_integration: "configuration_base_coordinates_with_execution_components_with_mcp"
    - discovery_integration: "configuration_base_coordinates_with_discovery_components"
    - monitoring_integration: "configuration_base_provides_metrics_to_monitoring_system"
    - mcp_integration: "configuration_base_orchestrates_mcp_server_discovery_and_validation"

# Version Management (Enhanced)
version_management:
  current_version: "0.3.0"
  architecture_version: "enhanced_5_phase_v0.3.0"
  compatibility_requirements:
    minimal_system_version: "0.3.0"
    required_components: ["mcp_server_discovery", "error_handling_initialization", "dependency_resolver"]

  migration_support:
    previous_version_support: false
    migration_strategy: "enhanced_with_mcp_integration"
    configuration_migration: "automatic_with_validation_and_fallback"

  enhancement_changes:
    what_was_enhanced:
      - "9 consolidated files → 10 files with dedicated MCP Server Discovery"
      - "4 dependency levels → 5 enhanced levels including MCP prerequisite"
      - "Consolidated loading strategy → Enhanced loading with MCP integration"
      - "Basic error handling → Enhanced error handling with MCP monitoring"
      - "Individual monitoring → Unified monitoring with MCP health tracking"
      - "TF-IDF system integration → Ultimate agent selection with MCP"
      - "Basic MCP integration → Comprehensive MCP discovery and validation"
      - "4-phase initialization → 5-phase initialization with MCP prerequisite"

    benefits_of_enhancement:
      - "100% MCP coverage with automatic discovery"
      - "Enhanced reliability through comprehensive MCP validation"
      - "Improved performance monitoring with MCP health tracking"
      - "Better error handling with MCP-specific fallback strategies"
      - "Enhanced cache system for MCP server data"
      - "Real-time MCP monitoring and optimization"
      - "Automatic MCP tool selection and fallback"