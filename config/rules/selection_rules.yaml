# Agent Selection Rules
# Clean rule definitions with pseudocode algorithms for LLM agent selection

metadata:
  name: "Agent Selection Rules"
  description: "Intelligent agent selection with comprehensive error handling and fallback strategies"
  version: "2.1.0"

# Selection Criteria
selection_criteria:
  complexity_thresholds:
    simple: 0.3
    medium: 0.6
    complex: 0.8
    very_complex: 1.0

  performance_thresholds:
    min_success_rate: 0.7
    max_response_time: 10.0
    min_reliability: 0.8

  availability_thresholds:
    max_load_ratio: 0.8
    min_availability: 0.2

  Task Analysis Rules
task_analysis_rules:
  # Keyword-based task classification
  keywords:
    analysis:
      primary: ["analyze", "analysis", "investigate", "review", "examine", "study", "research"]
      secondary: ["understand", "evaluate", "assess", "audit"]
      weight: 1.0

    design:
      primary: ["design", "architecture", "plan", "structure", "blueprint"]
      secondary: ["specify", "define", "outline", "schema"]
      weight: 1.0

    implementation:
      primary: ["implement", "create", "build", "develop", "code", "program"]
      secondary: ["write", "construct", "assemble", "fabricate"]
      weight: 1.0

    testing:
      primary: ["test", "testing", "validate", "verify", "check", "qa"]
      secondary: ["ensure", "confirm", "inspect", "examine"]
      weight: 1.0

    optimization:
      primary: ["optimize", "optimization", "improve", "enhance", "boost"]
      secondary: ["speed", "performance", "efficiency", "tune"]
      weight: 0.9

    security:
      primary: ["security", "secure", "protect", "safeguard", "harden"]
      secondary: ["vulnerability", "threat", "risk", "compliance"]
      weight: 1.0

    coordination:
      primary: ["coordinate", "orchestrate", "manage", "organize", "lead"]
      secondary: ["supervise", "direct", "guide", "facilitate"]
      weight: 0.8

    error_handling:
      primary: ["error", "fix", "debug", "troubleshoot", "recover", "resolve"]
      secondary: ["issue", "problem", "failure", "crash", "exception"]
      weight: 1.0

# Scoring System
scoring_system:
  weights:
    competency_match: 0.35
    performance_history: 0.25
    current_load: 0.20
    availability: 0.15
    cost_efficiency: 0.05

  Scoring Algorithms:
  competency_scoring:
    implementation: |
      # Competency-Based Scoring Algorithm
      INPUT: task_requirements, agent_competencies
      OUTPUT: competency_scores (0.0-1.0)
      
      PROCESS:
      1. Extract task requirements and agent competencies
      2. Calculate skill overlap (task_skills ∩ agent_skills)
      3. Score based on skill importance (primary=1.0, secondary=0.7, optional=0.5)
      4. Apply domain-specific adjustments
      5. Return highest score

  performance_scoring:
    implementation: |
      # Performance-Based Scoring Algorithm
      INPUT: task_context, agent_performance
      OUTPUT: performance_scores (0.0-1.0)
      
      PROCESS:
      1. Get historical success rate
      2. Calculate recent performance trend
      3. Apply time-based decay (newer is better)
      4. Apply domain expertise bonus
      5. Return final performance score

  availability_scoring:
    implementation: |
      # Availability-Based Scoring Algorithm
      INPUT: agent_capacity
      OUTPUT: availability_scores (0.0-1.0)
      
      PROCESS:
      1. Calculate availability ratio
      2. Apply sigmoid smoothing
      3. Apply confidence adjustments
      4. Return final score

  Hybrid Scoring:
    implementation: |
      # Combined Scoring Algorithm
      INPUT: all individual scores
      OUTPUT: final_scores (0.0-1.0)
      
      PROCESS:
      1. Apply weights: competency*0.35 + performance*0.25 + current_load*0.20 + availability*0.15 + cost_efficiency*0.05
      2. Normalize final scores
      3. Apply confidence adjustment
      4. Return top scoring agent

# Selection Strategies
selection_strategies:
  performance_first:
    name: "Performance First"
    weights:
      competency_match: 0.4
      performance_history: 0.4
      current_load: 0.1
      availability: 0.05
      cost_efficiency: 0.05
    use_case: "Critical tasks where quality is paramount"

  availability_first:
    name: "Availability First"
    weights:
      competency_match: 0.3
      performance_history: 0.2
      current_load: 0.3
      availability: 0.2
      cost_efficiency: 0.0
    use_case: "Time-sensitive tasks requiring immediate attention"

  balanced:
    name: "Balanced Approach"
    weights:
      competency_match: 0.35
      performance_history: 0.25
      current_load: 0.20
      availability: 0.15
      cost_efficiency: 0.05
    use_case: "Default strategy for most scenarios"

  cost_optimized:
    name: "Cost Optimized"
    weights:
      competency_match: 0.3
      performance_history: 0.2
      current_load: 0.2
      availability: 0.1
      cost_efficiency: 0.2
    use_case: "Budget-conscious scenarios with acceptable quality trade-offs"

# Fallback Rules
fallback_rules:
  no_suitable_agent:
  action: "Expand search criteria"
  options:
    - lower_competency_threshold: 0.1
    - increase_load_tolerance: 0.1
    consider_backup_agents: true
    enable_cross_domain_fallback: true
    use_general_purpose_as_last_resort: true

  all_agents_busy:
  action: "Intelligent queue management"
  options:
    priority_queue: true
    wait_time_limit: 300  # 5 minutes
    escalation_threshold: 2
    preempt_low_priority_tasks: true
    notify_user_of_delay: true

  selection_timeout:
  action: "Emergency selection protocol"
  options:
    ignore_load_constraints: true
    minimum_acceptance_score: 0.3
    select_least_loaded_available: true
    log_selection_difficulty: true

# Error Handling
error_handling_rules:
  error_detection:
  syntax_errors:
    triggers: ["parse errors", "format errors", "structure errors", "template errors"]
    priority: "medium"
    return_condition: "on_significant_syntax_error"

  logic_errors:
  triggers: ["algorithm errors", "logic flow errors", "decision errors", "reasoning errors"]
    priority: "high"
    return_condition: "on_logic_inconsistency"

  runtime_errors:
  triggers: ["runtime errors", "timeout errors", "resource errors", "performance errors"]
    priority: "high"
    return_condition: "on_performance_threshold_exceeded"

  error_recovery_workflows:
  recovery_steps:
  - 1. Detect and classify error
  2. Create comprehensive error report
    - "log_error_details: " + " + "timestamp", "error_type", "error_message", "stack_trace", "context"
  - "cleanup_partial_state": "Remove temporary files, scripts, directories"
  - "create_recovery_checkpoint": "Save successful outputs"
  - "attempt_graceful_degradation": "Attempt minimal functionality with reduced capabilities"
  - "request_additional_resources": "Ask for human assistance"
  - "escalate_to_orchestrator": "Escalate to human oversight if critical"

  task_continuation:
    auto_continue:
      condition: "error_fixed_and_state_preserved"
      action: "Resume from failed step"
      requirements: ["error_resolution", "state_preservation"]
    manual_review:
      condition: "security_or_critical_errors"
      action: "Require human approval before continuation"
      requirements: ["error_resolution", "human_approval"]
    restart_required:
      condition: "state_corrupted_or_unrecoverable"
      action: "Restart task from beginning"
      requirements: ["fresh_start", "error_prevention"]

  todo_framework_integration:
    error_handling_in_todos:
      todo_state_transitions:
        pending → in_progress → error_detected → error_reporting → error_delegated → error_resolved → in_progress → completed
        pending → in_progress → failed → error_reporting → error_delegated → error_resolved → restart_from_pending
      
      error_return_conditions_in_todos:
        todo_item_specification:
          error_return_condition: "specific_error_criteria"
          error_handling_strategy: "delegate_to_error_recovery_agent"
          continuation_plan: "resume_or_restart_after_fix"
      validation_checkpoints:
        - error_classification_accuracy: "Validate error classification accuracy"
        - recovery_effectiveness: "Assess recovery success rate"
        - continuation_strategy_validity: "Check if continuation plan is valid"

# Quality Assurance
quality_assurance:
  validation_rules:
    minimum_confidence: "Minimum confidence threshold for acceptance"
    maximum_categories: "Maximum number of categories to return"
    consistency_check: "Ensure logical category relationships"
    evidence_support: "Require substantial supporting evidence"
    cross_validation: "Cross-validate with historical data"
    user_acceptance_required: "User validation of results"

  performance_metrics:
  classification_precision: "Target > 0.85"
  recall_score: "Target > 0.80"
  user_satisfaction: "Target > 0.80"
  error_recovery_success: "Target > 90%"

# Integration Points
integration:
  imports:
    agent_selection_system:
      file: "config/knowledge-base/agent-selection.yaml"
      description: "Agent selection algorithms and hybrid scoring"
    tfidf_system:
      file: "config/knowledge-base/tfidf-system.yaml"
      description: "TF-IDF text processing system"
    task_analysis:
      file: "config/knowledge-base/task-analysis.yaml"
      description: "Task complexity assessment and classification"
    categorization_engine:
      file: "config/knowledge-base/categorization-engine.yaml"
      description: "ML-based task categorization"
    parallel_coordination:
      file: "config/knowledge-base/parallel_coordination.yaml"
      description: "Parallel execution coordination"

  export:
  agent_selection_results: "Selection scores and confidence scores"
  agent_performance_updates: "Performance metrics and learning data"
  learning_module: "Feedback integration and parameter optimization"

# Configuration Management
configuration_management:
  parameter_storage:
    current_configuration: "Active selection configuration"
    parameter_history: "Previous parameter versions"
    optimization_log: "Record of parameter adjustments"
    model_performance_history: "Historical model performance data"

  version_control:
  model_versioning: "Track model version changes"
  compatibility_checking: "Ensure backward compatibility"
  migration_support: "Assist with system upgrades"
  rollback_capability: "Restore previous configurations"